- name: up tests
  tags: up
  block:
  # Case 0: missing name and command parameter
  - name: up without name
    jclaveau.vagrant.up:
    register: up_result
    ignore_errors: true

  - name: dbg up_result
    ansible.builtin.debug:
      var: up_result
    tags:
    - never
    - debug

  - name: Vagrant up should fail
    assert:
      that:
        - up_result is failed
        - up_result is not changed
        - "up_result.msg == 'missing required arguments: name'"

  # Case 1: with a bad name
  - name: up with a bad name
    jclaveau.vagrant.up:
      name: non_existing_vm
    register: up_result
    ignore_errors: true

  - name: dbg up_result
    ansible.builtin.debug:
      var: up_result
    tags:
    - never
    - debug

  - name: Vagrant up should fail
    assert:
      that:
        - up_result is failed
        - up_result is not changed
        - >
          "Vagrant::Errors::MachineNotFound: The machine with the name 'non_existing_vm' was not found configured for this Vagrant environment." in up_result.msg
        - >
          "Vagrant::Errors::MachineNotFound: The machine with the name 'non_existing_vm' was not found configured for this Vagrant environment." in up_result.stderr_lines

  # Case: with a bad provider. It will fail as the box doesn't exists and so test the support of provider parameter AND error handling
  - name: up with a different provider
    jclaveau.vagrant.up:
    args:
      name: srv002
      provider: docker
    register: up_srv002_result
    ignore_errors: true

  - name: dbg up_result
    ansible.builtin.debug:
      var: up_srv002_result
    tags:
    - never
    - debug

  - name: check that Docker is installed
    ansible.builtin.shell: docker --version
    ignore_errors: true
    register: docker_version_result

  - name: Vagrant up with docker as provider should fail as the box doesn't exist for docker
    assert:
      that:
        - up_srv002_result is failed
        - up_srv002_result is not changed
        - >
          "Bringing machine 'srv002' up with 'docker' provider..." in up_srv002_result.stdout_lines
        - >
          "==> srv002: Box 'debian/buster64' could not be found. Attempting to find and install..." in up_srv002_result.stdout_lines

        - >
          "The box you're attempting to add doesn't support the provider" in up_srv002_result.stderr_lines
        - >
          "you requested. Please find an alternate box or use an alternate" in up_srv002_result.stderr_lines
        - >
          "provider. Double-check your requested provider to verify you didn't" in up_srv002_result.stderr_lines
        - >
          "simply misspell it." in up_srv002_result.stderr_lines
        - >
          "Name: debian/buster64" in up_srv002_result.stderr_lines
        - >
          "Address: https://vagrantcloud.com/debian/buster64" in up_srv002_result.stderr_lines
        - >
          "Requested provider: [:docker]" in up_srv002_result.stderr_lines
    when: docker_version_result is success


  - name: Vagrant up with docker as provider should fail as the box doesn't exist for docker
    assert:
      that:
        - up_srv002_result is failed
        - up_srv002_result is not changed
        - >
          "The executable 'docker' Vagrant is trying to run was not" in up_srv002_result.stderr_lines
        - >
          "found in the PATH variable. This is an error. Please verify" in up_srv002_result.stderr_lines
    when: docker_version_result is failed

  # Case 2: up 2 machines
  - name: destroy srv002 and srv001
    jclaveau.vagrant.destroy:
    args:
      name: "{{ item }}"
    loop:
      - srv001
      - srv002

  - name: Start the 2 vagrant instances (asynchronously if enabled)
    jclaveau.vagrant.up:
    args:
      name: "{{ item }}"
    loop:
      - "srv001"
      - "srv002"
    async: "{{ 90 if async_enabled else 0 }}"
    poll: 0
    register: async_loop

  - name: dbg async_loop
    ansible.builtin.debug:
      var: async_loop
    tags:
    - never
    - debug

  - name: wait for up to finish
    async_status:
      jid: "{{ item.ansible_job_id }}"
      mode: status
    retries: 120
    delay: 1
    loop: "{{async_loop.results}}"
    register: async_loop_jobs
    until: async_loop_jobs.finished
    when: async_enabled

  - set_fact:
      up_result: "{{ async_loop_jobs if async_enabled else async_loop }}"

  - name: dbg up results
    ansible.builtin.debug:
      var: up_result

  - name: Vagrant up should succeed
    assert:
      that:
        - up_result is success
        - up_result is changed
        - up_result.results[0].duration > 0
        - up_result.results[0].status_before == "not_created"
        - up_result.results[0].status_after == "running"
        - up_result.results[1].duration > 0
        - up_result.results[1].status_before == "not_created"
        - up_result.results[1].status_after == "running"
        - '"==> srv001: Booting VM..." in up_result.results[0].stdout_lines'
        - '"==> srv002: Booting VM..." in up_result.results[1].stdout_lines'

  # Case 3: with provisioning forced
  - name: destroy srv002
    jclaveau.vagrant.destroy:
    args:
      name: srv002

  - name: up srv002 with provisioning (even if already provisionned)
    jclaveau.vagrant.up:
    args:
      name: srv002
      provision: true
    register: up_srv002_result

  - name: dbg up_result
    ansible.builtin.debug:
      var: up_srv002_result
    tags:
    - never
    - debug

  - name: Vagrant up with forced provisionning for srv002 only should succeed (no stdout line indicating forced provisionning)
    assert:
      that:
        - up_srv002_result is success
        - up_srv002_result is changed
        - up_srv002_result.duration > 0
        - up_srv002_result.status_before == "not_created"
        - up_srv002_result.status_after == "running"
        - up_srv002_result.stderr_lines == []
        - >
          "==> srv002: Booting VM..." in up_srv002_result.stdout_lines
        - >
          "==> srv002: Machine booted and ready!" in up_srv002_result.stdout_lines

  # Case 4: with provisioning for shell only
  - name: destroy srv002
    jclaveau.vagrant.destroy:
    args:
      name: srv002

  - name: up with provisionning for shell only
    jclaveau.vagrant.up:
    args:
      name: srv002
      provision_with: shell
    register: up_srv002_result

  - name: dbg up_result
    ansible.builtin.debug:
      var: up_srv002_result
    tags:
    - never
    - debug

  - name: Vagrant up with provisionning for shell only should succeed
    assert:
      that:
        - up_srv002_result is success
        - up_srv002_result is changed
        - up_srv002_result.duration > 0
        - up_srv002_result.status_before == "not_created"
        - up_srv002_result.status_after == "running"
        - up_srv002_result.stderr_lines == []
        - >
          "==> srv002: Booting VM..." in up_srv002_result.stdout_lines
        - >
          "==> srv002: Machine booted and ready!" in up_srv002_result.stdout_lines
        - >
          "==> srv002: Running provisioner: shell..." in up_srv002_result.stdout_lines
        - >
          "    srv002: Running: inline script" in up_srv002_result.stdout_lines
        - >
          "    srv002: srv002" in up_srv002_result.stdout_lines

  # Case 4: idempotence
  - name: up idempotence
    jclaveau.vagrant.up:
    args:
      name: srv002
    register: up_srv002_result

  - name: dbg up_result
    ansible.builtin.debug:
      var: up_srv002_result
    tags:
    - never
    - debug

  - name: Vagrant up already done
    assert:
      that:
        - up_srv002_result is success
        - up_srv002_result is not changed
        - up_srv002_result.duration > 0
        - up_srv002_result.status_before == "running"
        - up_srv002_result.status_after == "running"
        - up_srv002_result.stderr_lines == []
        - up_srv002_result.stdout_lines == []
